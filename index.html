<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=no">
  <title>Doober's Adventures</title>
  <style>
    * { margin: 0; padding: 0; box-sizing: border-box; }
    html, body {
      width: 100%;
      height: 100%;
      overflow: hidden;
    }
    body {
      background: linear-gradient(135deg, #1a1a2e 0%, #16213e 100%);
      display: flex;
      flex-direction: column;
      align-items: center;
      justify-content: center;
      min-height: 100vh;
      font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
      touch-action: none;
    }
    #game-container {
      position: relative;
      border-radius: 12px;
      overflow: hidden;
      box-shadow: 0 8px 32px rgba(0,0,0,0.6), 0 0 60px rgba(255,200,100,0.1);
      border: 3px solid #3a2a1a;
      max-width: 100vw;
      max-height: 90vh;
    }
    canvas { display: block; }
    #ui {
      position: absolute;
      top: 10px;
      left: 10px;
      right: 10px;
      display: flex;
      justify-content: space-between;
      pointer-events: none;
      z-index: 100;
    }
    #mute-btn {
      pointer-events: auto;
      background: rgba(0,0,0,0.6);
      border: 2px solid rgba(255,255,255,0.3);
      border-radius: 50%;
      width: 40px;
      height: 40px;
      display: flex;
      align-items: center;
      justify-content: center;
      cursor: pointer;
      font-size: 20px;
      color: white;
      transition: all 0.2s;
    }
    #mute-btn:hover { background: rgba(0,0,0,0.8); transform: scale(1.1); }
    .meter {
      background: rgba(0,0,0,0.75);
      border-radius: 16px;
      padding: 10px 16px;
      color: white;
      font-size: 13px;
      font-weight: bold;
      backdrop-filter: blur(4px);
      border: 1px solid rgba(255,255,255,0.1);
    }
    .meter-label { display: flex; align-items: center; gap: 6px; }
    .meter-bar-bg {
      height: 14px;
      background: rgba(0,0,0,0.5);
      border-radius: 7px;
      margin-top: 6px;
      overflow: hidden;
      min-width: 120px;
    }
    .meter-bar {
      height: 100%;
      border-radius: 7px;
      transition: width 0.3s ease;
    }
    #mischief-fill { background: linear-gradient(90deg, #f39c12, #e74c3c); }
    #anger-fill { background: linear-gradient(90deg, #e74c3c, #8e44ad); }
    #phase-indicator {
      position: absolute;
      bottom: 12px;
      left: 50%;
      transform: translateX(-50%);
      background: rgba(0,0,0,0.8);
      color: white;
      padding: 8px 20px;
      border-radius: 20px;
      font-size: 14px;
      font-weight: bold;
      backdrop-filter: blur(4px);
      border: 1px solid rgba(255,255,255,0.15);
      z-index: 100;
    }
    #room-indicator {
      position: absolute;
      top: 70px;
      left: 50%;
      transform: translateX(-50%);
      background: rgba(0,0,0,0.6);
      color: #ffeaa7;
      padding: 4px 14px;
      border-radius: 12px;
      font-size: 12px;
      z-index: 100;
      opacity: 0;
      transition: opacity 0.3s;
    }
    #room-indicator.visible { opacity: 1; }
    #message {
      position: absolute;
      top: 50%;
      left: 50%;
      transform: translate(-50%, -50%);
      background: rgba(0,0,0,0.9);
      color: white;
      padding: 32px 48px;
      border-radius: 20px;
      font-size: 26px;
      text-align: center;
      display: none;
      z-index: 200;
      border: 2px solid rgba(255,255,255,0.2);
      box-shadow: 0 8px 32px rgba(0,0,0,0.5);
    }
    #message button {
      margin-top: 20px;
      padding: 14px 36px;
      font-size: 18px;
      border: none;
      border-radius: 10px;
      background: linear-gradient(135deg, #27ae60, #2ecc71);
      color: white;
      cursor: pointer;
      font-weight: bold;
      transition: transform 0.1s, box-shadow 0.1s;
    }
    #message button:hover {
      transform: scale(1.05);
      box-shadow: 0 4px 15px rgba(46, 204, 113, 0.4);
    }
    #minimap {
      position: absolute;
      bottom: 50px;
      right: 10px;
      border: 2px solid rgba(255,255,255,0.3);
      border-radius: 8px;
      opacity: 0.8;
      z-index: 100;
    }
    #mute-btn {
      position: absolute;
      top: 10px;
      right: 10px;
      background: rgba(0,0,0,0.75);
      border: 1px solid rgba(255,255,255,0.2);
      border-radius: 50%;
      width: 44px;
      height: 44px;
      font-size: 20px;
      cursor: pointer;
      z-index: 150;
      display: flex;
      align-items: center;
      justify-content: center;
      transition: transform 0.1s, background 0.2s;
      backdrop-filter: blur(4px);
    }
    #mute-btn:hover {
      transform: scale(1.1);
      background: rgba(0,0,0,0.9);
    }
    #mute-btn.muted {
      opacity: 0.6;
    }
    #instructions {
      color: #a0a0a0;
      margin-top: 12px;
      text-align: center;
      font-size: 12px;
    }
    
    /* ============================================ */
    /* TITLE SCREEN STYLES */
    /* ============================================ */
    @import url('https://fonts.googleapis.com/css2?family=Fredoka+One&family=Nunito:wght@400;700&display=swap');
    
    #title-screen {
      position: absolute;
      top: 0;
      left: 0;
      right: 0;
      bottom: 0;
      background: linear-gradient(180deg, #87CEEB 0%, #98D8AA 60%, #5D8233 100%);
      display: flex;
      flex-direction: column;
      align-items: center;
      justify-content: center;
      z-index: 500;
      overflow: hidden;
    }
    
    #title-screen.hidden {
      display: none;
    }
    
    .title-clouds {
      position: absolute;
      top: 0;
      left: 0;
      right: 0;
      height: 40%;
      overflow: hidden;
      pointer-events: none;
    }
    
    .cloud {
      position: absolute;
      background: white;
      border-radius: 50px;
      opacity: 0.9;
      animation: float-cloud 20s linear infinite;
    }
    
    .cloud::before, .cloud::after {
      content: '';
      position: absolute;
      background: white;
      border-radius: 50%;
    }
    
    .cloud-1 { width: 80px; height: 30px; top: 15%; left: -100px; animation-duration: 25s; }
    .cloud-1::before { width: 40px; height: 40px; top: -20px; left: 10px; }
    .cloud-1::after { width: 50px; height: 50px; top: -25px; left: 35px; }
    
    .cloud-2 { width: 100px; height: 35px; top: 25%; left: -120px; animation-duration: 30s; animation-delay: 5s; }
    .cloud-2::before { width: 50px; height: 50px; top: -25px; left: 15px; }
    .cloud-2::after { width: 60px; height: 60px; top: -30px; left: 45px; }
    
    .cloud-3 { width: 70px; height: 25px; top: 10%; left: -80px; animation-duration: 22s; animation-delay: 10s; }
    .cloud-3::before { width: 35px; height: 35px; top: -18px; left: 8px; }
    .cloud-3::after { width: 45px; height: 45px; top: -22px; left: 30px; }
    
    @keyframes float-cloud {
      from { transform: translateX(0); }
      to { transform: translateX(calc(100vw + 200px)); }
    }
    
    .title-house {
      position: absolute;
      bottom: 15%;
      width: 200px;
      height: 150px;
      background: #D4A574;
      border: 4px solid #8B4513;
      border-radius: 5px;
    }
    
    .title-house::before {
      content: '';
      position: absolute;
      top: -80px;
      left: -20px;
      width: 0;
      height: 0;
      border-left: 120px solid transparent;
      border-right: 120px solid transparent;
      border-bottom: 80px solid #8B4513;
    }
    
    .title-logo {
      position: relative;
      z-index: 10;
      text-align: center;
      margin-bottom: 40px;
    }
    
    .title-main {
      font-family: 'Fredoka One', cursive;
      font-size: 64px;
      color: #8B4513;
      text-shadow: 
        4px 4px 0 #FFF,
        -2px -2px 0 #FFF,
        2px -2px 0 #FFF,
        -2px 2px 0 #FFF,
        0 6px 0 rgba(0,0,0,0.2);
      animation: title-bounce 2s ease-in-out infinite;
    }
    
    .title-subtitle {
      font-family: 'Nunito', sans-serif;
      font-size: 24px;
      color: #5D4E37;
      margin-top: 10px;
      text-shadow: 1px 1px 0 #FFF;
    }
    
    .title-doober {
      font-size: 80px;
      animation: doober-wiggle 1s ease-in-out infinite;
      display: inline-block;
    }
    
    @keyframes title-bounce {
      0%, 100% { transform: translateY(0); }
      50% { transform: translateY(-10px); }
    }
    
    @keyframes doober-wiggle {
      0%, 100% { transform: rotate(-5deg); }
      50% { transform: rotate(5deg); }
    }
    
    .menu-buttons {
      display: flex;
      flex-direction: column;
      gap: 16px;
      z-index: 10;
    }
    
    .menu-btn {
      font-family: 'Fredoka One', cursive;
      font-size: 24px;
      padding: 16px 48px;
      border: 4px solid #5D4E37;
      border-radius: 16px;
      cursor: pointer;
      transition: all 0.2s ease;
      box-shadow: 0 6px 0 rgba(0,0,0,0.3);
      position: relative;
      overflow: hidden;
    }
    
    .menu-btn:hover {
      transform: translateY(-4px);
      box-shadow: 0 10px 0 rgba(0,0,0,0.3);
    }
    
    .menu-btn:active {
      transform: translateY(2px);
      box-shadow: 0 2px 0 rgba(0,0,0,0.3);
    }
    
    .btn-play {
      background: linear-gradient(180deg, #4CAF50, #388E3C);
      color: white;
    }
    
    .btn-how {
      background: linear-gradient(180deg, #2196F3, #1976D2);
      color: white;
    }
    
    .btn-credits {
      background: linear-gradient(180deg, #9C27B0, #7B1FA2);
      color: white;
    }
    
    /* How to Play Modal */
    #how-to-play {
      position: absolute;
      top: 0;
      left: 0;
      right: 0;
      bottom: 0;
      background: rgba(0,0,0,0.85);
      display: none;
      flex-direction: column;
      align-items: center;
      justify-content: center;
      z-index: 600;
      padding: 20px;
    }
    
    #how-to-play.visible {
      display: flex;
    }
    
    .modal-content {
      background: linear-gradient(180deg, #FFF8E7, #FFE4B5);
      border: 4px solid #8B4513;
      border-radius: 20px;
      padding: 30px 40px;
      max-width: 500px;
      text-align: center;
      font-family: 'Nunito', sans-serif;
      box-shadow: 0 10px 40px rgba(0,0,0,0.5);
    }
    
    .modal-content h2 {
      font-family: 'Fredoka One', cursive;
      color: #8B4513;
      font-size: 32px;
      margin-bottom: 20px;
    }
    
    .how-section {
      text-align: left;
      margin: 20px 0;
      padding: 15px;
      background: rgba(255,255,255,0.5);
      border-radius: 10px;
    }
    
    .how-section h3 {
      color: #5D4E37;
      font-size: 18px;
      margin-bottom: 8px;
    }
    
    .how-section p {
      color: #666;
      font-size: 14px;
      line-height: 1.5;
    }
    
    .controls-grid {
      display: grid;
      grid-template-columns: 1fr 1fr;
      gap: 10px;
      margin-top: 10px;
    }
    
    .control-key {
      background: #333;
      color: white;
      padding: 8px 12px;
      border-radius: 6px;
      font-weight: bold;
      font-size: 12px;
    }
    
    /* Credits Modal */
    #credits-modal {
      position: absolute;
      top: 0;
      left: 0;
      right: 0;
      bottom: 0;
      background: rgba(0,0,0,0.85);
      display: none;
      flex-direction: column;
      align-items: center;
      justify-content: center;
      z-index: 600;
      padding: 20px;
    }
    
    #credits-modal.visible {
      display: flex;
    }
    
    .credits-content {
      background: linear-gradient(180deg, #2C3E50, #1a252f);
      border: 4px solid #F39C12;
      border-radius: 20px;
      padding: 30px 40px;
      max-width: 400px;
      text-align: center;
      font-family: 'Nunito', sans-serif;
      box-shadow: 0 10px 40px rgba(0,0,0,0.5);
      color: white;
    }
    
    .credits-content h2 {
      font-family: 'Fredoka One', cursive;
      color: #F39C12;
      font-size: 32px;
      margin-bottom: 20px;
    }
    
    .credit-line {
      margin: 12px 0;
      font-size: 16px;
    }
    
    .credit-line strong {
      color: #F39C12;
    }
    
    .close-btn {
      margin-top: 20px;
      font-family: 'Fredoka One', cursive;
      font-size: 18px;
      padding: 12px 32px;
      background: linear-gradient(180deg, #E74C3C, #C0392B);
      color: white;
      border: 3px solid #922B21;
      border-radius: 10px;
      cursor: pointer;
      transition: transform 0.1s;
    }
    
    .close-btn:hover {
      transform: scale(1.05);
    }
    
    /* Animated meter improvements */
    .meter-bar {
      position: relative;
      overflow: hidden;
    }
    
    .meter-bar::after {
      content: '';
      position: absolute;
      top: 0;
      left: -100%;
      width: 50%;
      height: 100%;
      background: linear-gradient(90deg, transparent, rgba(255,255,255,0.3), transparent);
      animation: meter-shine 2s ease-in-out infinite;
    }
    
    @keyframes meter-shine {
      0% { left: -100%; }
      50%, 100% { left: 100%; }
    }
    
    /* Phase transition animation */
    .phase-flash {
      animation: phase-flash 0.5s ease-out;
    }
    
    @keyframes phase-flash {
      0% { transform: translateX(-50%) scale(1.5); opacity: 0; }
      50% { opacity: 1; }
      100% { transform: translateX(-50%) scale(1); }
    }
  </style>
</head>
<body>
  <div id="game-container">
    <canvas id="game"></canvas>
    <div id="ui">
      <div class="meter" id="mischief-meter">
        <div class="meter-label">üêï Mischief</div>
        <div class="meter-bar-bg"><div id="mischief-fill" class="meter-bar" style="width: 0%;"></div></div>
      </div>
      <div id="mute-btn" onclick="toggleMute()">üîä</div>
      <div class="meter" id="anger-meter" style="display: none;">
        <div class="meter-label">üò† Owner Anger</div>
        <div class="meter-bar-bg"><div id="anger-fill" class="meter-bar" style="width: 100%;"></div></div>
      </div>
    </div>
    <div id="room-indicator">Kitchen</div>
    <div id="phase-indicator">üêï Cause mischief!</div>
    <canvas id="minimap" width="120" height="100"></canvas>
    <button id="mute-btn" onclick="toggleMute()" title="Toggle Sound">üîä</button>
    <div id="message">
      <div id="message-text"></div>
      <button onclick="startGame()">Play Again</button>
      <button onclick="returnToMenu()" style="margin-left: 10px; background: linear-gradient(135deg, #3498db, #2980b9);">Main Menu</button>
    </div>
    
    <!-- Title Screen -->
    <div id="title-screen">
      <div class="title-clouds">
        <div class="cloud cloud-1"></div>
        <div class="cloud cloud-2"></div>
        <div class="cloud cloud-3"></div>
      </div>
      
      <div class="title-logo">
        <div class="title-doober">üêï</div>
        <div class="title-main">Doober's Adventures</div>
        <div class="title-subtitle">A Mischievous Beagle's Tale</div>
      </div>
      
      <div class="menu-buttons">
        <button class="menu-btn btn-play" onclick="startGameFromMenu()">üéÆ Play Game</button>
        <button class="menu-btn btn-how" onclick="showHowToPlay()">üìñ How to Play</button>
        <button class="menu-btn btn-credits" onclick="showCredits()">‚≠ê Credits</button>
      </div>
    </div>
    
    <!-- How to Play Modal -->
    <div id="how-to-play">
      <div class="modal-content">
        <h2>üìñ How to Play</h2>
        
        <div class="how-section">
          <h3>üéØ Goal</h3>
          <p>Be a mischievous beagle! Cause trouble around the house, but don't get caught by Mom or Dad!</p>
        </div>
        
        <div class="how-section">
          <h3>üïπÔ∏è Controls</h3>
          <div class="controls-grid">
            <span class="control-key">‚Üë W</span><span>Move Up</span>
            <span class="control-key">‚Üì S</span><span>Move Down</span>
            <span class="control-key">‚Üê A</span><span>Move Left</span>
            <span class="control-key">‚Üí D</span><span>Move Right</span>
          </div>
        </div>
        
        <div class="how-section">
          <h3>üêï Gameplay</h3>
          <p><strong>Phase 1:</strong> Fill the mischief meter by causing trouble!<br>
          <strong>Phase 2:</strong> Hide until the owners calm down!<br>
          Win their love to become the ultimate good boy! üíï</p>
        </div>
        
        <button class="close-btn" onclick="hideHowToPlay()">Got It!</button>
      </div>
    </div>
    
    <!-- Credits Modal -->
    <div id="credits-modal">
      <div class="credits-content">
        <h2>‚≠ê Credits</h2>
        
        <div class="credit-line"><strong>Game Design:</strong> Bob Bullock</div>
        <div class="credit-line"><strong>Art Style:</strong> Inspired by Stardew Valley</div>
        <div class="credit-line"><strong>Sprites:</strong> AI Generated (Gemini)</div>
        <div class="credit-line"><strong>Code:</strong> OpenClaw AI</div>
        <div class="credit-line" style="margin-top: 20px; font-size: 14px; opacity: 0.8;">
          Made with üêïüíï for all the mischievous beagles out there!
        </div>
        
        <button class="close-btn" onclick="hideCredits()">Back</button>
      </div>
    </div>
  </div>
  <div id="instructions">Arrow keys / WASD to move ‚Ä¢ Cause trouble ‚Ä¢ Hide when owners are mad!</div>

<script>
<script>
// ============================================
// AUDIO SYSTEM (Synthesized placeholders)
// ============================================
// MOBILE CONTROLS (Virtual Joystick)
// ============================================
class VirtualJoystick {
  constructor() {
    this.active = false;
    this.baseX = 0;
    this.baseY = 0;
    this.maxDist = 50;
    this.input = { up: false, down: false, left: false, right: false };
    
    // Create UI elements
    this.base = document.createElement('div');
    this.base.style.cssText = `
      position: absolute; width: 100px; height: 100px;
      border-radius: 50%; background: rgba(255, 255, 255, 0.1);
      border: 2px solid rgba(255, 255, 255, 0.3);
      display: none; pointer-events: none; z-index: 1000;
      backdrop-filter: blur(2px);
    `;
    this.stick = document.createElement('div');
    this.stick.style.cssText = `
      position: absolute; width: 40px; height: 40px;
      border-radius: 50%; background: rgba(255, 255, 255, 0.5);
      top: 50%; left: 50%; transform: translate(-50%, -50%);
      box-shadow: 0 0 10px rgba(0,0,0,0.2);
    `;
    this.base.appendChild(this.stick);
    document.body.appendChild(this.base);
    
    // Event listeners attached to game container to prevent scrolling
    const container = document.getElementById('game-container');
    container.addEventListener('touchstart', this.onTouchStart.bind(this), { passive: false });
    container.addEventListener('touchmove', this.onTouchMove.bind(this), { passive: false });
    container.addEventListener('touchend', this.onTouchEnd.bind(this));
  }
  
  onTouchStart(e) {
    // Only handle first touch for movement
    if (this.active) return;
    
    e.preventDefault();
    const touch = e.changedTouches[0];
    this.active = true;
    this.id = touch.identifier;
    this.baseX = touch.clientX;
    this.baseY = touch.clientY;
    
    this.base.style.display = 'block';
    this.base.style.left = (this.baseX - 50) + 'px';
    this.base.style.top = (this.baseY - 50) + 'px';
    this.stick.style.transform = `translate(-50%, -50%)`;
    
    // Initialize Audio on first touch if needed
    audioManager.init();
  }
  
  onTouchMove(e) {
    if (!this.active) return;
    e.preventDefault();
    
    // Find our touch
    let touch = null;
    for (let i = 0; i < e.changedTouches.length; i++) {
      if (e.changedTouches[i].identifier === this.id) {
        touch = e.changedTouches[i];
        break;
      }
    }
    if (!touch) return;
    
    const dx = touch.clientX - this.baseX;
    const dy = touch.clientY - this.baseY;
    const dist = Math.sqrt(dx*dx + dy*dy);
    const angle = Math.atan2(dy, dx);
    
    const limitDist = Math.min(dist, this.maxDist);
    const stickX = Math.cos(angle) * limitDist;
    const stickY = Math.sin(angle) * limitDist;
    
    this.stick.style.transform = `translate(calc(-50% + ${stickX}px), calc(-50% + ${stickY}px))`;
    
    // Deadzone of 10px
    if (dist > 10) {
      this.input.right = dx > 20;
      this.input.left = dx < -20;
      this.input.down = dy > 20;
      this.input.up = dy < -20;
    } else {
      this.input = { up: false, down: false, left: false, right: false };
    }
  }
  
  onTouchEnd(e) {
    for (let i = 0; i < e.changedTouches.length; i++) {
      if (e.changedTouches[i].identifier === this.id) {
        this.active = false;
        this.base.style.display = 'none';
        this.input = { up: false, down: false, left: false, right: false };
        break;
      }
    }
  }
}

const joystick = new VirtualJoystick();

// ============================================
// DOOBER'S ADVENTURES - Full House Edition v2
// ============================================

const canvas = document.getElementById('game');
const ctx = canvas.getContext('2d');
const minimapCanvas = document.getElementById('minimap');
const minimapCtx = minimapCanvas.getContext('2d');

// ============================================
// AUDIO SYSTEM
// ============================================
class AudioManager {
  constructor() {
    this.ctx = null;
    this.masterGain = null;
    this.isMuted = false;
    this.sounds = {};
    this.musicNodes = {};
    this.initialized = false;
    this.lastFootstep = 0;
  }

  init() {
    if (this.initialized) return;
    
    try {
      const AudioContext = window.AudioContext || window.webkitAudioContext;
      this.ctx = new AudioContext();
      this.masterGain = this.ctx.createGain();
      this.masterGain.connect(this.ctx.destination);
      this.masterGain.gain.value = 0.5; // Default volume
      this.initialized = true;
      console.log('Audio initialized');
    } catch (e) {
      console.error('Web Audio API not supported', e);
    }
  }

  toggleMute() {
    if (!this.initialized) this.init();
    this.isMuted = !this.isMuted;
    if (this.masterGain) {
      this.masterGain.gain.value = this.isMuted ? 0 : 0.5;
    }
    const btn = document.getElementById('mute-btn');
    if (btn) btn.textContent = this.isMuted ? 'üîá' : 'üîä';
    return this.isMuted;
  }

  // Generate synthetic sounds using oscillators
  playSfx(type) {
    if (!this.initialized || this.isMuted) return;
    if (this.ctx.state === 'suspended') this.ctx.resume();

    const t = this.ctx.currentTime;
    const osc = this.ctx.createOscillator();
    const gain = this.ctx.createGain();
    
    osc.connect(gain);
    gain.connect(this.masterGain);

    switch (type) {
      case 'footstep':
        // Short blip
        if (t - this.lastFootstep < 0.25) return; // Debounce footsteps
        this.lastFootstep = t;
        osc.type = 'triangle';
        osc.frequency.setValueAtTime(150, t);
        osc.frequency.exponentialRampToValueAtTime(50, t + 0.05);
        gain.gain.setValueAtTime(0.3, t);
        gain.gain.exponentialRampToValueAtTime(0.01, t + 0.05);
        osc.start(t);
        osc.stop(t + 0.05);
        break;

      case 'mischief':
        // Descending "uh oh" tone
        osc.type = 'sine';
        osc.frequency.setValueAtTime(400, t);
        osc.frequency.linearRampToValueAtTime(200, t + 0.2);
        gain.gain.setValueAtTime(0.5, t);
        gain.gain.linearRampToValueAtTime(0.01, t + 0.2);
        osc.start(t);
        osc.stop(t + 0.2);
        break;

      case 'phase-change':
        // Sweep up
        osc.type = 'sawtooth';
        osc.frequency.setValueAtTime(200, t);
        osc.frequency.exponentialRampToValueAtTime(800, t + 0.3);
        gain.gain.setValueAtTime(0.3, t);
        gain.gain.linearRampToValueAtTime(0.01, t + 0.3);
        osc.start(t);
        osc.stop(t + 0.3);
        break;

      case 'caught':
        // Alarm tone
        osc.type = 'square';
        osc.frequency.setValueAtTime(600, t);
        osc.frequency.setValueAtTime(400, t + 0.25);
        gain.gain.setValueAtTime(0.4, t);
        gain.gain.linearRampToValueAtTime(0.01, t + 0.5);
        osc.start(t);
        osc.stop(t + 0.5);
        break;

      case 'win':
        // Happy ascending notes (arpeggio)
        this.playNote(523.25, t, 0.2); // C5
        this.playNote(659.25, t + 0.2, 0.2); // E5
        this.playNote(783.99, t + 0.4, 0.4); // G5
        break;
        
      case 'click':
        // Soft click
        osc.type = 'sine';
        osc.frequency.setValueAtTime(800, t);
        gain.gain.setValueAtTime(0.1, t);
        gain.gain.exponentialRampToValueAtTime(0.01, t + 0.05);
        osc.start(t);
        osc.stop(t + 0.05);
        break;
    }
  }

  playNote(freq, time, duration) {
    const osc = this.ctx.createOscillator();
    const gain = this.ctx.createGain();
    osc.connect(gain);
    gain.connect(this.masterGain);
    osc.type = 'sine';
    osc.frequency.setValueAtTime(freq, time);
    gain.gain.setValueAtTime(0.3, time);
    gain.gain.exponentialRampToValueAtTime(0.01, time + duration);
    osc.start(time);
    osc.stop(time + duration);
  }
}

const audioManager = new AudioManager();

function toggleMute() {
  audioManager.toggleMute();
}

// ============================================
// SPRITE LOADING SYSTEM
// ============================================
const sprites = {
  doober: { img: null, loaded: false, frameWidth: 64, frameHeight: 64 },
  mom: { img: null, loaded: false, frameWidth: 64, frameHeight: 64 },
  dad: { img: null, loaded: false, frameWidth: 64, frameHeight: 64 },
};

// Tileset images
const tilesets = {
  floors: { img: null, loaded: false },
  furniture: { img: null, loaded: false },
};

let spritesLoaded = 0;
const totalSprites = 3;

function loadSprite(name, src) {
  const img = new Image();
  img.onload = () => {
    sprites[name].img = img;
    sprites[name].loaded = true;
    // Auto-detect frame size (assume 4x4 grid)
    sprites[name].frameWidth = img.width / 4;
    sprites[name].frameHeight = img.height / 4;
    spritesLoaded++;
    console.log(`Loaded sprite: ${name} (${img.width}x${img.height}, frame: ${sprites[name].frameWidth}x${sprites[name].frameHeight})`);
  };
  img.onerror = () => {
    console.warn(`Failed to load sprite: ${name}, using fallback`);
    spritesLoaded++; // Count as loaded to not block game
  };
  img.src = src;
}

function loadTileset(name, src) {
  const img = new Image();
  img.onload = () => {
    tilesets[name].img = img;
    tilesets[name].loaded = true;
    console.log(`Loaded tileset: ${name} (${img.width}x${img.height})`);
  };
  img.onerror = () => {
    console.warn(`Failed to load tileset: ${name}, using fallback colors`);
  };
  img.src = src;
}

// Load all sprites
loadSprite('doober', 'assets/sprites/doober-spritesheet.png');
loadSprite('mom', 'assets/sprites/mom-spritesheet.png');
loadSprite('dad', 'assets/sprites/dad-spritesheet.png');

// Load tilesets
loadTileset('floors', 'assets/sprites/floor-tiles.png');
loadTileset('furniture', 'assets/sprites/furniture-tiles.png');

// Draw a sprite frame from a spritesheet
function drawSprite(spriteName, frameX, frameY, x, y, scale = 1, flipX = false) {
  const sprite = sprites[spriteName];
  if (!sprite || !sprite.loaded || !sprite.img) return false;
  
  const fw = sprite.frameWidth;
  const fh = sprite.frameHeight;
  const drawW = fw * scale;
  const drawH = fh * scale;
  
  ctx.save();
  if (flipX) {
    ctx.translate(x + drawW/2, y);
    ctx.scale(-1, 1);
    ctx.translate(-drawW/2, 0);
    ctx.drawImage(sprite.img, frameX * fw, frameY * fh, fw, fh, 0, 0, drawW, drawH);
  } else {
    ctx.drawImage(sprite.img, frameX * fw, frameY * fh, fw, fh, x, y, drawW, drawH);
  }
  ctx.restore();
  return true;
}
// ============================================

// Responsive sizing - fill browser width, maintain 16:9 aspect ratio
const TILE = 32;
const ASPECT_RATIO = 16 / 9;

function resizeCanvas() {
  const maxWidth = window.innerWidth - 20;
  const maxHeight = window.innerHeight * 0.85;
  
  let width = maxWidth;
  let height = width / ASPECT_RATIO;
  
  if (height > maxHeight) {
    height = maxHeight;
    width = height * ASPECT_RATIO;
  }
  
  canvas.width = Math.floor(width);
  canvas.height = Math.floor(height);
  
  // Update viewport tiles
  VIEWPORT_COLS = Math.ceil(canvas.width / TILE);
  VIEWPORT_ROWS = Math.ceil(canvas.height / TILE);
}

let VIEWPORT_COLS = 20;
let VIEWPORT_ROWS = 12;
resizeCanvas();
window.addEventListener('resize', resizeCanvas);

// Map dimensions (60x50 = 3000 tiles)
const MAP_COLS = 60;
const MAP_ROWS = 50;

// Camera
const camera = { x: 0, y: 0 };

// Game state
let gamePhase = 'mischief';
let mischiefLevel = 0;
let angerLevel = 100;
const MISCHIEF_MAX = 100;
const MISCHIEF_TRIGGER = 80;
let currentRoom = '';

// Tile types
const T = {
  FLOOR: 0,
  WALL: 1,
  FURNITURE: 2,
  MISCHIEF: 3,
  HIDING: 4,
  DOOR: 5,
  GRASS: 6,
  WATER: 7,
  COUNTER: 8,
  TABLE: 9,
  COUCH: 10,
  BED: 11,
  TV: 12,
  TOILET: 13,
  TUB: 14,
  FENCE: 15,
};

// Room definitions (adjusted for 1-tile walls)
const rooms = {
  kitchen:    { x: 1,  y: 21, w: 16, h: 14, name: 'Kitchen', color: '#f5e6d3' },
  dining:     { x: 18, y: 21, w: 14, h: 14, name: 'Dining Room', color: '#f0e0c8' },
  living:     { x: 33, y: 17, w: 26, h: 18, name: 'Living Room', color: '#e8dcc8' },
  entry:      { x: 1,  y: 36, w: 12, h: 12, name: 'Entry', color: '#d8cbb8' },
  backyard:   { x: 14, y: 36, w: 45, h: 13, name: 'Backyard', color: '#90c970' },
  bathroom:   { x: 1,  y: 5,  w: 10, h: 10, name: 'Bathroom', color: '#d0e8f0' },
  bedroom:    { x: 12, y: 3,  w: 18, h: 12, name: 'Bedroom', color: '#e8d8c8' },
  kidsroom:   { x: 31, y: 3,  w: 16, h: 12, name: "Kid's Room", color: '#f8e8d0' },
  hallway:    { x: 1,  y: 16, w: 58, h: 4,  name: 'Hallway', color: '#d0c4b0' },
};

// Generate the map
const houseMap = [];
const collisionMap = [];
for (let y = 0; y < MAP_ROWS; y++) {
  houseMap[y] = [];
  collisionMap[y] = [];
  for (let x = 0; x < MAP_COLS; x++) {
    houseMap[y][x] = T.WALL;
    collisionMap[y][x] = 1;
  }
}

// Helper to fill rooms
function fillRoom(room, floorType = T.FLOOR) {
  for (let y = room.y; y < room.y + room.h; y++) {
    for (let x = room.x; x < room.x + room.w; x++) {
      if (x >= 0 && x < MAP_COLS && y >= 0 && y < MAP_ROWS) {
        houseMap[y][x] = floorType;
        collisionMap[y][x] = 0;
      }
    }
  }
}

function placeTile(x, y, type, solid = true) {
  if (x >= 0 && x < MAP_COLS && y >= 0 && y < MAP_ROWS) {
    houseMap[y][x] = type;
    collisionMap[y][x] = solid ? 1 : 0;
  }
}

function placeRect(x, y, w, h, type, solid = true) {
  for (let dy = 0; dy < h; dy++) {
    for (let dx = 0; dx < w; dx++) {
      placeTile(x + dx, y + dy, type, solid);
    }
  }
}

// Fill all rooms
Object.values(rooms).forEach(r => {
  fillRoom(r, r.name === 'Backyard' ? T.GRASS : T.FLOOR);
});

// Add doors (2+ tiles wide)
function addDoor(x, y, width = 2, vertical = true) {
  for (let i = 0; i < width; i++) {
    if (vertical) {
      placeTile(x + i, y, T.DOOR, false);
    } else {
      placeTile(x, y + i, T.DOOR, false);
    }
  }
}

// Hallway to rooms doors (2 tiles wide each)
addDoor(6, 20, 3, true);    // kitchen to hallway
addDoor(22, 20, 3, true);   // dining to hallway
addDoor(40, 16, 3, true);   // living to hallway
addDoor(4, 15, 2, true);    // bathroom to hallway
addDoor(18, 15, 3, true);   // bedroom to hallway
addDoor(38, 15, 3, true);   // kids room to hallway
addDoor(6, 35, 3, true);    // entry to kitchen
addDoor(14, 40, 2, false);  // entry to backyard (horizontal)
addDoor(33, 35, 3, true);   // living to backyard

// Kitchen furniture
placeRect(2, 22, 14, 2, T.COUNTER, true);   // top counter
placeRect(2, 24, 2, 8, T.COUNTER, true);    // left counter
placeRect(14, 24, 2, 6, T.COUNTER, true);   // right counter

// Dining room furniture
placeRect(21, 25, 5, 4, T.TABLE, true);     // dining table

// Living room furniture
placeRect(36, 19, 8, 3, T.COUCH, true);     // couch
placeRect(52, 18, 4, 5, T.TV, true);        // TV

// Bedroom furniture
placeRect(14, 5, 5, 4, T.BED, true);        // bed
placeRect(26, 5, 3, 4, T.FURNITURE, true);  // dresser

// Kid's room furniture
placeRect(33, 5, 4, 3, T.BED, true);        // kid bed
placeRect(43, 5, 3, 3, T.FURNITURE, true);  // toy chest

// Bathroom furniture
placeTile(3, 8, T.TOILET, true);
placeRect(7, 7, 3, 3, T.TUB, true);

// Backyard
placeRect(14, 36, 45, 1, T.FENCE, true);    // top fence
placeRect(14, 48, 45, 1, T.FENCE, true);    // bottom fence
placeRect(14, 36, 1, 13, T.FENCE, true);    // left fence
placeRect(58, 36, 1, 13, T.FENCE, true);    // right fence

// Mischief spots
const mischiefSpots = [
  // Kitchen
  { x: 4, y: 30, name: 'Trash Can', room: 'kitchen', points: 15, used: false, emoji: 'üóëÔ∏è' },
  { x: 12, y: 26, name: 'Counter Food', room: 'kitchen', points: 20, used: false, emoji: 'üçñ' },
  // Dining
  { x: 23, y: 27, name: 'TURKEY!', room: 'dining', points: 35, used: false, emoji: 'ü¶É' },
  // Living
  { x: 50, y: 28, name: 'Dad\'s Shoes', room: 'living', points: 15, used: false, emoji: 'üëü' },
  { x: 38, y: 22, name: 'Couch Cushions', room: 'living', points: 20, used: false, emoji: 'üõãÔ∏è' },
  { x: 56, y: 24, name: 'Potted Plant', room: 'living', points: 15, used: false, emoji: 'ü™¥' },
  // Entry
  { x: 4, y: 42, name: 'Shoe Rack', room: 'entry', points: 15, used: false, emoji: 'üëû' },
  // Bathroom
  { x: 3, y: 9, name: 'Toilet Water', room: 'bathroom', points: 10, used: false, emoji: 'üöΩ' },
  { x: 5, y: 11, name: 'Toilet Paper', room: 'bathroom', points: 15, used: false, emoji: 'üßª' },
  // Bedroom
  { x: 16, y: 10, name: 'Pillows', room: 'bedroom', points: 15, used: false, emoji: 'üõèÔ∏è' },
  { x: 27, y: 8, name: 'Laundry', room: 'bedroom', points: 20, used: false, emoji: 'üß¶' },
  // Kid's room
  { x: 36, y: 10, name: 'Chew Toys', room: 'kidsroom', points: 15, used: false, emoji: 'üß∏' },
  { x: 44, y: 12, name: 'Homework', room: 'kidsroom', points: 25, used: false, emoji: 'üìù' },
  // Backyard
  { x: 25, y: 42, name: 'Dig Garden', room: 'backyard', points: 20, used: false, emoji: 'üå∑' },
  { x: 40, y: 44, name: 'Dig Lawn', room: 'backyard', points: 15, used: false, emoji: 'üï≥Ô∏è' },
  { x: 52, y: 40, name: 'Chase Bird', room: 'backyard', points: 10, used: false, emoji: 'üê¶' },
];

// Mark mischief spots on map
mischiefSpots.forEach(spot => {
  placeTile(spot.x, spot.y, T.MISCHIEF, false);
});

// Hiding spots
const hidingSpots = [
  { x: 8, y: 28, name: 'Behind Counter', room: 'kitchen' },
  { x: 24, y: 30, name: 'Under Table', room: 'dining' },
  { x: 42, y: 24, name: 'Behind Couch', room: 'living' },
  { x: 55, y: 30, name: 'Behind Curtains', room: 'living' },
  { x: 8, y: 44, name: 'Coat Closet', room: 'entry' },
  { x: 8, y: 10, name: 'Shower Curtain', room: 'bathroom' },
  { x: 14, y: 10, name: 'Under Bed', room: 'bedroom' },
  { x: 28, y: 12, name: 'In Closet', room: 'bedroom' },
  { x: 33, y: 10, name: 'Under Kid Bed', room: 'kidsroom' },
  { x: 44, y: 8, name: 'Toy Chest', room: 'kidsroom' },
  { x: 20, y: 44, name: 'Doghouse', room: 'backyard' },
  { x: 48, y: 42, name: 'Bushes', room: 'backyard' },
];

// Mark hiding spots
hidingSpots.forEach(spot => {
  placeTile(spot.x, spot.y, T.HIDING, false);
});

// Doober - improved movement (high initial speed, lower top speed, snappy)
const doober = {
  x: 8, y: 17,
  targetX: 8, targetY: 17,
  velX: 0, velY: 0,
  maxSpeed: 0.18,       // Lower top speed for control
  accel: 0.9,           // Very high acceleration (reach top speed almost instantly)
  friction: 0.85,       // Friction when no input
  hidden: false,
  tailWag: 0,
  facing: 1,
  moving: false,
  // Animation
  animFrame: 0,
  animTimer: 0,
  direction: 0, // 0=down, 1=up, 2=right, 3=left
};

// Owners
const owners = [
  {
    name: 'Mom',
    x: 8, y: 26,
    homeX: 8, homeY: 26,
    targetX: 8, targetY: 26,
    speed: 0.04,
    state: 'idle',
    gender: 'female',
    spriteName: 'mom',
    searchPath: [],
    pathIndex: 0,
    hearts: [],
    animFrame: 0,
    animTimer: 0,
    direction: 0,
  },
  {
    name: 'Dad',
    x: 40, y: 22,
    homeX: 40, homeY: 22,
    targetX: 40, targetY: 22,
    speed: 0.035,
    state: 'idle',
    gender: 'male',
    spriteName: 'dad',
    searchPath: [],
    pathIndex: 0,
    hearts: [],
    animFrame: 0,
    animTimer: 0,
    direction: 0,
  },
];

// Simple A* pathfinding
function findPath(startX, startY, endX, endY) {
  const start = { x: Math.round(startX), y: Math.round(startY) };
  const end = { x: Math.round(endX), y: Math.round(endY) };
  
  if (start.x === end.x && start.y === end.y) return [];
  
  const openSet = [{ ...start, g: 0, h: 0, f: 0, parent: null }];
  const closedSet = new Set();
  
  function heuristic(a, b) {
    return Math.abs(a.x - b.x) + Math.abs(a.y - b.y);
  }
  
  function key(n) { return `${n.x},${n.y}`; }
  
  while (openSet.length > 0) {
    openSet.sort((a, b) => a.f - b.f);
    const current = openSet.shift();
    
    if (current.x === end.x && current.y === end.y) {
      const path = [];
      let node = current;
      while (node.parent) {
        path.unshift({ x: node.x, y: node.y });
        node = node.parent;
      }
      return path;
    }
    
    closedSet.add(key(current));
    
    const neighbors = [
      { x: current.x + 1, y: current.y },
      { x: current.x - 1, y: current.y },
      { x: current.x, y: current.y + 1 },
      { x: current.x, y: current.y - 1 },
    ];
    
    for (const n of neighbors) {
      if (n.x < 0 || n.x >= MAP_COLS || n.y < 0 || n.y >= MAP_ROWS) continue;
      if (collisionMap[n.y][n.x] === 1) continue;
      if (closedSet.has(key(n))) continue;
      
      const g = current.g + 1;
      const h = heuristic(n, end);
      const f = g + h;
      
      const existing = openSet.find(o => o.x === n.x && o.y === n.y);
      if (existing) {
        if (g < existing.g) {
          existing.g = g;
          existing.f = f;
          existing.parent = current;
        }
      } else {
        openSet.push({ ...n, g, h, f, parent: current });
      }
    }
    
    if (openSet.length > 500) break;
  }
  
  return [];
}

// Colors
// Stardew Valley inspired color palette
const colors = {
  [T.FLOOR]: '#d4a574',     // Warm wood floor
  [T.WALL]: '#8b7355',      // Rich brown walls
  [T.FURNITURE]: '#a67c52', // Warm furniture wood
  [T.MISCHIEF]: '#ffeb99',  // Glowing yellow highlight
  [T.HIDING]: '#9b8bd4',    // Soft purple
  [T.DOOR]: '#c9956c',      // Door frame
  [T.GRASS]: '#5a9c3e',     // Vibrant grass green
  [T.WATER]: '#5bb5d4',     // Clear water blue
  [T.COUNTER]: '#b8956e',   // Kitchen counter
  [T.TABLE]: '#9c7a5a',     // Dining table
  [T.COUCH]: '#6b7ec2',     // Cozy blue-purple couch
  [T.BED]: '#c490b8',       // Soft pink/purple bed
  [T.TV]: '#3a4a5a',        // Dark TV
  [T.TOILET]: '#e8e8e8',    // White porcelain
  [T.TUB]: '#a8d8ea',       // Light blue tub
  [T.FENCE]: '#7a5c45',     // Wood fence
};

// Room colors - warmer, more saturated Stardew palette
const roomColors = {
  'Kitchen': '#e8d4b8',      // Warm cream kitchen
  'Dining Room': '#dcc8a8',  // Soft tan dining
  'Living Room': '#d8c4a4',  // Cozy living room
  'Entry': '#c8b898',        // Welcoming entry
  'Backyard': '#7cb860',     // Lush grass
  'Bathroom': '#c8e0e8',     // Clean blue-white
  'Bedroom': '#e0d0c0',      // Soft bedroom
  "Kid's Room": '#e8dcc8',   // Warm kid's room
  'Hallway': '#c8b8a0',      // Neutral hallway
};

// Input - track held keys for smooth movement
const keys = { up: false, down: false, left: false, right: false };

document.addEventListener('keydown', (e) => {
  if (gamePhase === 'win' || gamePhase === 'lose') return;
  
  if (e.key === 'ArrowUp' || e.key === 'w' || e.key === 'W') keys.up = true;
  else if (e.key === 'ArrowDown' || e.key === 's' || e.key === 'S') keys.down = true;
  else if (e.key === 'ArrowLeft' || e.key === 'a' || e.key === 'A') keys.left = true;
  else if (e.key === 'ArrowRight' || e.key === 'd' || e.key === 'D') keys.right = true;
  else return;
  
  e.preventDefault();
});

document.addEventListener('keyup', (e) => {
  if (e.key === 'ArrowUp' || e.key === 'w' || e.key === 'W') keys.up = false;
  else if (e.key === 'ArrowDown' || e.key === 's' || e.key === 'S') keys.down = false;
  else if (e.key === 'ArrowLeft' || e.key === 'a' || e.key === 'A') keys.left = false;
  else if (e.key === 'ArrowRight' || e.key === 'd' || e.key === 'D') keys.right = false;
});

function distance(a, b) {
  return Math.sqrt((a.x - b.x) ** 2 + (a.y - b.y) ** 2);
}

function getCurrentRoom(x, y) {
  for (const [name, room] of Object.entries(rooms)) {
    if (x >= room.x && x < room.x + room.w && y >= room.y && y < room.y + room.h) {
      return room.name;
    }
  }
  return '';
}

// Floating text effects
let floatingTexts = [];
let particles = [];

function showFloatingText(x, y, text, color = '#e74c3c') {
  floatingTexts.push({ x, y, text, color, life: 60 });
}

function createParticles(x, y, color, count = 10) {
  for (let i = 0; i < count; i++) {
    particles.push({
      x: x, y: y,
      vx: (Math.random() - 0.5) * 6,
      vy: (Math.random() - 0.5) * 6,
      life: 30 + Math.random() * 20,
      color: color,
      size: 3 + Math.random() * 4
    });
  }
}

function updateOwner(owner) {
  if (owner.state === 'idle') return;
  
  if (owner.state === 'searching') {
    if (owner.searchPath.length === 0 || owner.pathIndex >= owner.searchPath.length) {
      const searchPoints = [
        { x: 8, y: 17 },  { x: 30, y: 17 }, { x: 50, y: 17 },
        { x: 8, y: 28 },  { x: 24, y: 28 }, { x: 45, y: 25 },
        { x: 6, y: 42 },  { x: 6, y: 10 },  { x: 20, y: 8 },
        { x: 38, y: 8 },  { x: 30, y: 42 },
      ];
      const target = searchPoints[Math.floor(Math.random() * searchPoints.length)];
      owner.searchPath = findPath(owner.x, owner.y, target.x, target.y);
      owner.pathIndex = 0;
    }
    
    if (owner.searchPath.length > 0 && owner.pathIndex < owner.searchPath.length) {
      const next = owner.searchPath[owner.pathIndex];
      const dx = next.x - owner.x;
      const dy = next.y - owner.y;
      
      if (Math.abs(dx) > 0.1 || Math.abs(dy) > 0.1) {
        owner.x += Math.sign(dx) * owner.speed;
        owner.y += Math.sign(dy) * owner.speed;
      } else {
        owner.pathIndex++;
      }
    }
  }
  
  if (owner.state === 'returning') {
    const dx = owner.homeX - owner.x;
    const dy = owner.homeY - owner.y;
    
    if (Math.abs(dx) > 0.5 || Math.abs(dy) > 0.5) {
      if (owner.searchPath.length === 0) {
        owner.searchPath = findPath(owner.x, owner.y, owner.homeX, owner.homeY);
        owner.pathIndex = 0;
      }
      
      if (owner.searchPath.length > 0 && owner.pathIndex < owner.searchPath.length) {
        const next = owner.searchPath[owner.pathIndex];
        const pdx = next.x - owner.x;
        const pdy = next.y - owner.y;
        
        if (Math.abs(pdx) > 0.1 || Math.abs(pdy) > 0.1) {
          owner.x += Math.sign(pdx) * owner.speed * 0.7;
          owner.y += Math.sign(pdy) * owner.speed * 0.7;
        } else {
          owner.pathIndex++;
        }
      }
    } else {
      owner.x = owner.homeX;
      owner.y = owner.homeY;
      owner.state = 'idle';
      owner.searchPath = [];
    }
  }
}

function canMoveTo(x, y) {
  const checkX = Math.round(x);
  const checkY = Math.round(y);
  if (checkX < 0 || checkX >= MAP_COLS || checkY < 0 || checkY >= MAP_ROWS) return false;
  return collisionMap[checkY][checkX] === 0;
}

function update() {
  // Handle input - apply velocity based on held keys
  let inputX = 0, inputY = 0;
  if (keys.up || joystick.input.up) inputY = -1;
  if (keys.down || joystick.input.down) inputY = 1;
  if (keys.left || joystick.input.left) { inputX = -1; doober.facing = -1; }
  if (keys.right || joystick.input.right) { inputX = 1; doober.facing = 1; }
  
  doober.moving = inputX !== 0 || inputY !== 0;
  
  if (doober.moving) {
    audioManager.playSfx('footstep');
  }
  
  // Apply acceleration (very fast to reach top speed)
  if (inputX !== 0) {
    doober.velX += inputX * doober.accel * doober.maxSpeed;
  } else {
    doober.velX *= doober.friction;
  }
  
  if (inputY !== 0) {
    doober.velY += inputY * doober.accel * doober.maxSpeed;
  } else {
    doober.velY *= doober.friction;
  }
  
  // Clamp to max speed
  const speed = Math.sqrt(doober.velX ** 2 + doober.velY ** 2);
  if (speed > doober.maxSpeed) {
    doober.velX = (doober.velX / speed) * doober.maxSpeed;
    doober.velY = (doober.velY / speed) * doober.maxSpeed;
  }
  
  // Stop if very slow
  if (Math.abs(doober.velX) < 0.01) doober.velX = 0;
  if (Math.abs(doober.velY) < 0.01) doober.velY = 0;
  
  // Move with collision
  const newX = doober.x + doober.velX;
  const newY = doober.y + doober.velY;
  
  if (canMoveTo(newX, doober.y)) {
    doober.x = newX;
  } else {
    doober.velX = 0;
  }
  
  if (canMoveTo(doober.x, newY)) {
    doober.y = newY;
  } else {
    doober.velY = 0;
  }
  
  doober.tailWag += doober.moving ? 0.25 : 0.1;
  
  // Update current room
  const room = getCurrentRoom(doober.x, doober.y);
  if (room !== currentRoom) {
    currentRoom = room;
    const indicator = document.getElementById('room-indicator');
    indicator.textContent = room || 'Hallway';
    indicator.classList.add('visible');
    setTimeout(() => indicator.classList.remove('visible'), 2000);
  }
  
  // Check hiding
  doober.hidden = false;
  if (gamePhase === 'hide') {
    for (const spot of hidingSpots) {
      if (distance(doober, spot) < 1.2) {
        doober.hidden = true;
        break;
      }
    }
  }
  
  // Update camera
  camera.x = Math.max(0, Math.min(MAP_COLS - VIEWPORT_COLS, doober.x - VIEWPORT_COLS / 2));
  camera.y = Math.max(0, Math.min(MAP_ROWS - VIEWPORT_ROWS, doober.y - VIEWPORT_ROWS / 2));
  
  // Phase logic
  if (gamePhase === 'mischief') {
    document.getElementById('phase-indicator').textContent = 'üêï Cause mischief!';
    
    for (const spot of mischiefSpots) {
      if (!spot.used && distance(doober, spot) < 1.2) {
        spot.used = true;
        audioManager.playSfx('mischief');
        mischiefLevel = Math.min(MISCHIEF_MAX, mischiefLevel + spot.points);
        showFloatingText(spot.x * TILE, spot.y * TILE, `+${spot.points} ${spot.emoji}`, '#f39c12');
        if (typeof createParticles === 'function') createParticles(spot.x * TILE + TILE/2, spot.y * TILE + TILE/2, '#f39c12', 15);
      }
    }
    
    if (mischiefLevel >= MISCHIEF_TRIGGER) {
      gamePhase = 'hide';
      angerLevel = 100;
      owners.forEach(o => {
        o.state = 'searching';
        o.searchPath = [];
      });
      document.getElementById('mischief-meter').style.display = 'none';
      document.getElementById('anger-meter').style.display = 'block';
      animatePhaseChange('üôà HIDE! Owners are looking!');
      audioManager.playSfx('phase-change');
    }
  } else if (gamePhase === 'hide') {
    document.getElementById('phase-indicator').textContent = 'üôà HIDE! Owners are looking!';
    
    for (const owner of owners) {
      updateOwner(owner);
      
      if (!doober.hidden && distance(doober, owner) < 2) {
        gamePhase = 'lose';
        showMessage('üêïüì¶ CAUGHT!<br>Doober goes in the crate...');
        audioManager.playSfx('caught');
        return;
      }
    }
    
    angerLevel -= 0.08;
    document.getElementById('anger-fill').style.width = angerLevel + '%';
    
    if (angerLevel <= 0) {
      angerLevel = 0;
      gamePhase = 'calm';
      owners.forEach(o => {
        o.state = 'returning';
        o.searchPath = [];
      });
      animatePhaseChange('üíï Go get love from owners!');
      audioManager.playSfx('phase-change');
    }
  } else if (gamePhase === 'calm') {
    document.getElementById('phase-indicator').textContent = 'üíï Go get love from owners!';
    
    for (const owner of owners) {
      updateOwner(owner);
      
      if (owner.state === 'idle' && distance(doober, owner) < 2) {
        gamePhase = 'win';
        showMessage('üíïüíïüíï YOU WIN! üíïüíïüíï<br>The owners love Doober!');
        audioManager.playSfx('win');
        return;
      }
    }
  }
  
  document.getElementById('mischief-fill').style.width = (mischiefLevel / MISCHIEF_MAX * 100) + '%';
  
  for (let i = floatingTexts.length - 1; i >= 0; i--) {
    floatingTexts[i].y -= 0.5;
    floatingTexts[i].life--;
    if (floatingTexts[i].life <= 0) floatingTexts.splice(i, 1);
  }
  
  for (let i = particles.length - 1; i >= 0; i--) {
    let p = particles[i];
    p.x += p.vx;
    p.y += p.vy;
    p.vy += 0.2; // Gravity
    p.life--;
    if (p.life <= 0) particles.splice(i, 1);
  }
}

function draw() {
  ctx.clearRect(0, 0, canvas.width, canvas.height);
  
  const startCol = Math.floor(camera.x);
  const startRow = Math.floor(camera.y);
  const offsetX = (camera.x - startCol) * TILE;
  const offsetY = (camera.y - startRow) * TILE;
  
  // Draw tiles
  for (let row = 0; row <= VIEWPORT_ROWS + 1; row++) {
    for (let col = 0; col <= VIEWPORT_COLS + 1; col++) {
      const mapX = startCol + col;
      const mapY = startRow + row;
      
      if (mapX < 0 || mapX >= MAP_COLS || mapY < 0 || mapY >= MAP_ROWS) continue;
      
      const tile = houseMap[mapY][mapX];
      const screenX = col * TILE - offsetX;
      const screenY = row * TILE - offsetY;
      
      let floorColor = colors[tile] || colors[T.FLOOR];
      if (tile === T.FLOOR || tile === T.DOOR) {
        const roomName = getCurrentRoom(mapX, mapY);
        // Use new roomColors palette
        if (roomColors[roomName]) {
          floorColor = roomColors[roomName];
        }
      }
      
      ctx.fillStyle = floorColor;
      ctx.fillRect(screenX, screenY, TILE + 1, TILE + 1);
      
      // Add subtle wood grain pattern to floors
      if (tile === T.FLOOR || tile === T.DOOR) {
        ctx.fillStyle = 'rgba(0,0,0,0.03)';
        for (let i = 0; i < 3; i++) {
          ctx.fillRect(screenX + (mapX * 7 + i * 11) % TILE, screenY, 1, TILE);
        }
      }
      
      if (tile === T.WALL) {
        // Rich textured walls
        ctx.fillStyle = colors[T.WALL];
        ctx.fillRect(screenX, screenY, TILE, TILE);
        // Highlight at top
        ctx.fillStyle = 'rgba(255,255,255,0.15)';
        ctx.fillRect(screenX, screenY, TILE, 2);
        // Shadow at bottom
        ctx.fillStyle = 'rgba(0,0,0,0.25)';
        ctx.fillRect(screenX, screenY + TILE - 3, TILE, 3);
        // Subtle vertical grain
        ctx.fillStyle = 'rgba(0,0,0,0.05)';
        ctx.fillRect(screenX + 8, screenY, 1, TILE);
        ctx.fillRect(screenX + 24, screenY, 1, TILE);
      } else if (tile === T.COUNTER || tile === T.TABLE || tile === T.FURNITURE) {
        // Rounded furniture with highlight
        ctx.fillStyle = colors[tile];
        ctx.fillRect(screenX + 2, screenY + 2, TILE - 4, TILE - 4);
        ctx.fillStyle = 'rgba(255,255,255,0.2)';
        ctx.fillRect(screenX + 3, screenY + 3, TILE - 6, 2);
        ctx.fillStyle = 'rgba(0,0,0,0.15)';
        ctx.fillRect(screenX + 2, screenY + TILE - 5, TILE - 4, 3);
      } else if (tile === T.COUCH) {
        // Cozy couch with cushion detail
        ctx.fillStyle = colors[T.COUCH];
        ctx.fillRect(screenX + 1, screenY + 1, TILE - 2, TILE - 2);
        ctx.fillStyle = 'rgba(255,255,255,0.25)';
        ctx.fillRect(screenX + 4, screenY + 4, TILE - 8, 6);
        ctx.fillStyle = 'rgba(0,0,0,0.1)';
        ctx.fillRect(screenX + 4, screenY + 12, TILE - 8, 2);
      } else if (tile === T.BED) {
        // Comfy bed with pillow
        ctx.fillStyle = colors[T.BED];
        ctx.fillRect(screenX + 1, screenY + 1, TILE - 2, TILE - 2);
        // Pillow
        ctx.fillStyle = '#fff';
        ctx.fillRect(screenX + 3, screenY + 3, TILE - 10, 8);
        ctx.fillStyle = 'rgba(0,0,0,0.05)';
        ctx.fillRect(screenX + 3, screenY + 9, TILE - 10, 2);
        // Blanket fold
        ctx.fillStyle = 'rgba(255,255,255,0.2)';
        ctx.fillRect(screenX + 3, screenY + 14, TILE - 6, 2);
      } else if (tile === T.TV) {
        // TV with glowing screen
        ctx.fillStyle = colors[T.TV];
        ctx.fillRect(screenX + 2, screenY + 2, TILE - 4, TILE - 4);
        // Screen glow
        ctx.fillStyle = '#a0d4f7';
        ctx.fillRect(screenX + 5, screenY + 5, TILE - 10, TILE - 12);
        // Screen reflection
        ctx.fillStyle = 'rgba(255,255,255,0.3)';
        ctx.fillRect(screenX + 6, screenY + 6, 4, 2);
      } else if (tile === T.GRASS) {
        // Lush grass with blades
        ctx.fillStyle = roomColors['Backyard'];
        ctx.fillRect(screenX, screenY, TILE + 1, TILE + 1);
        ctx.fillStyle = '#4a8c30';
        for (let i = 0; i < 4; i++) {
          const gx = screenX + 4 + (i * 7) + ((mapX + mapY) % 3);
          const gy = screenY + 12 + Math.sin(mapX + mapY + i) * 4;
          ctx.fillRect(gx, gy, 2, 8);
        }
      } else if (tile === T.FENCE) {
        ctx.fillStyle = colors[T.FENCE];
        ctx.fillRect(screenX + TILE/2 - 2, screenY, 4, TILE);
        ctx.fillRect(screenX, screenY + 6, TILE, 3);
        ctx.fillRect(screenX, screenY + TILE - 9, TILE, 3);
        // Wood grain
        ctx.fillStyle = 'rgba(0,0,0,0.1)';
        ctx.fillRect(screenX + TILE/2 - 1, screenY, 1, TILE);
      } else if (tile === T.TOILET) {
        ctx.fillStyle = colors[T.TOILET];
        ctx.beginPath();
        ctx.ellipse(screenX + TILE/2, screenY + TILE/2, TILE/3, TILE/2.5, 0, 0, Math.PI * 2);
        ctx.fill();
        // Rim shadow
        ctx.strokeStyle = 'rgba(0,0,0,0.1)';
        ctx.lineWidth = 2;
        ctx.stroke();
      } else if (tile === T.TUB) {
        ctx.fillStyle = colors[T.TUB];
        ctx.fillRect(screenX + 2, screenY + 2, TILE - 4, TILE - 4);
        ctx.strokeStyle = '#6bc4e8';
        ctx.lineWidth = 2;
        ctx.strokeRect(screenX + 2, screenY + 2, TILE - 4, TILE - 4);
        // Water ripple
        ctx.strokeStyle = 'rgba(255,255,255,0.4)';
        ctx.beginPath();
        ctx.arc(screenX + TILE/2, screenY + TILE/2, 6, 0, Math.PI * 2);
        ctx.stroke();
      }
      
      if (tile === T.MISCHIEF && gamePhase === 'mischief') {
        const spot = mischiefSpots.find(s => s.x === mapX && s.y === mapY);
        if (spot && !spot.used) {
          ctx.fillStyle = 'rgba(255, 234, 167, 0.6)';
          ctx.beginPath();
          ctx.arc(screenX + TILE/2, screenY + TILE/2, TILE/2.5 + Math.sin(doober.tailWag * 2) * 2, 0, Math.PI * 2);
          ctx.fill();
          ctx.font = '16px sans-serif';
          ctx.fillText(spot.emoji, screenX + TILE/2 - 8, screenY + TILE/2 + 6);
        }
      }
      
      if (tile === T.HIDING && gamePhase === 'hide') {
        ctx.fillStyle = `rgba(162, 155, 254, ${0.4 + Math.sin(doober.tailWag * 2) * 0.2})`;
        ctx.fillRect(screenX + 2, screenY + 2, TILE - 4, TILE - 4);
        ctx.font = '12px sans-serif';
        ctx.fillText('üõãÔ∏è', screenX + TILE/2 - 6, screenY + TILE/2 + 4);
      }
    }
  }
  
  // Draw owners
  for (const owner of owners) {
    const ox = (owner.x - camera.x) * TILE;
    const oy = (owner.y - camera.y) * TILE;
    
    if (ox < -TILE || ox > canvas.width + TILE || oy < -TILE || oy > canvas.height + TILE) continue;
    
    const cx = ox + TILE/2;
    const cy = oy + TILE/2;
    
    // Update owner animation - speed tied to movement state
    if (owner.state === 'searching' || owner.state === 'returning') {
      // Walking - animate based on owner speed
      owner.animTimer += owner.speed * 30;
      if (owner.animTimer >= 1) {
        owner.animTimer = 0;
        owner.animFrame = (owner.animFrame + 1) % 4;
      }
    } else {
      // Idle - slow subtle animation
      owner.animTimer += 0.03;
      if (owner.animTimer >= 1) {
        owner.animTimer = 0;
        owner.animFrame = (owner.animFrame + 1) % 4;
      }
    }
    
    // Determine sprite row based on state
    // Row 0: idle, Row 1: walk down, Row 2: walk right, Row 3: emotions
    let spriteRow = 0;
    let spriteFrame = owner.animFrame;
    let flipX = false;
    
    if (owner.state === 'searching' || owner.state === 'returning') {
      // Walking - use walk animation
      spriteRow = 1; // Default walk down
      // Could detect direction from path if needed
    }
    
    // For emotion states, use row 3
    if (owner.state === 'searching') {
      // Could use angry frame from row 3
    }
    
    // Calculate sprite scale
    const spriteScale = TILE * 1.3 / (sprites[owner.spriteName]?.frameWidth || 64);
    const offsetX = ox - TILE * 0.15;
    const offsetY = oy - TILE * 0.4;
    
    // Try to draw sprite, fall back to canvas drawing
    if (!drawSprite(owner.spriteName, spriteFrame, spriteRow, offsetX, offsetY, spriteScale, flipX)) {
      // Fallback: canvas-drawn owner
      // Angry pulse effect
      let angryPulse = 0;
      if (owner.state === 'searching') {
        angryPulse = Math.sin(Date.now() / 100) * 0.3 + 0.7;
      }
      
      ctx.save();
      
      // Shadow
      ctx.fillStyle = 'rgba(0,0,0,0.2)';
      ctx.beginPath();
      ctx.ellipse(cx, cy + TILE/3, TILE/2.5, TILE/5, 0, 0, Math.PI * 2);
      ctx.fill();
      
      // Body
      if (owner.gender === 'female') {
        ctx.fillStyle = '#e91e63';
        ctx.beginPath();
        ctx.moveTo(cx - TILE/4, cy - 2);
        ctx.lineTo(cx + TILE/4, cy - 2);
        ctx.lineTo(cx + TILE/3, cy + TILE/3);
        ctx.lineTo(cx - TILE/3, cy + TILE/3);
        ctx.closePath();
        ctx.fill();
        ctx.fillStyle = '#c2185b';
        ctx.fillRect(cx - 2, cy + 2, 4, TILE/4);
      } else {
        ctx.fillStyle = '#1976d2';
        ctx.beginPath();
        ctx.ellipse(cx, cy + 4, TILE/3.5, TILE/4, 0, 0, Math.PI * 2);
        ctx.fill();
        ctx.fillStyle = '#5d4037';
        ctx.fillRect(cx - TILE/5, cy + TILE/5, TILE/2.5, TILE/6);
      }
      
      // Head
      let skinColor = '#ffcc99';
      if (owner.state === 'searching') {
        const red = Math.floor(255 * angryPulse);
        const green = Math.floor(120 * (1 - angryPulse * 0.5));
        const blue = Math.floor(120 * (1 - angryPulse * 0.5));
        skinColor = `rgb(${red}, ${green}, ${blue})`;
      }
      ctx.fillStyle = skinColor;
      ctx.beginPath();
      ctx.arc(cx, cy - 6, TILE/3.2, 0, Math.PI * 2);
      ctx.fill();
      
      // Hair
      if (owner.gender === 'female') {
        ctx.fillStyle = '#5d4037';
        ctx.beginPath();
        ctx.arc(cx, cy - 9, TILE/3.5, Math.PI, Math.PI * 2);
        ctx.fill();
        ctx.beginPath();
        ctx.ellipse(cx - 7, cy - 4, 3, 8, -0.2, 0, Math.PI * 2);
        ctx.fill();
        ctx.beginPath();
        ctx.ellipse(cx + 7, cy - 4, 3, 8, 0.2, 0, Math.PI * 2);
        ctx.fill();
      } else {
        ctx.fillStyle = '#3e2723';
        ctx.beginPath();
        ctx.arc(cx, cy - 10, TILE/4, Math.PI, Math.PI * 2);
        ctx.fill();
      }
      
      // Eyes
      ctx.fillStyle = '#ffffff';
      ctx.beginPath();
      ctx.arc(cx - 4, cy - 7, 3, 0, Math.PI * 2);
      ctx.arc(cx + 4, cy - 7, 3, 0, Math.PI * 2);
      ctx.fill();
      ctx.fillStyle = '#1a1a1a';
      ctx.beginPath();
      ctx.arc(cx - 4, cy - 7, 1.5, 0, Math.PI * 2);
      ctx.arc(cx + 4, cy - 7, 1.5, 0, Math.PI * 2);
      ctx.fill();
      
      // Expression
      if (owner.state === 'searching') {
        ctx.strokeStyle = '#3e2723';
        ctx.lineWidth = 2;
        ctx.beginPath();
        ctx.moveTo(cx - 7, cy - 12);
        ctx.lineTo(cx - 2, cy - 10);
        ctx.moveTo(cx + 7, cy - 12);
        ctx.lineTo(cx + 2, cy - 10);
        ctx.stroke();
        ctx.beginPath();
        ctx.arc(cx, cy - 1, 3, 0, Math.PI, true);
        ctx.stroke();
        ctx.font = '10px sans-serif';
        ctx.fillText('üí¢', cx + 8, cy - 14);
      } else if (gamePhase === 'calm' || gamePhase === 'win') {
        ctx.strokeStyle = '#d32f2f';
        ctx.lineWidth = 1.5;
        ctx.beginPath();
        ctx.arc(cx, cy - 3, 4, 0, Math.PI);
        ctx.stroke();
        ctx.fillStyle = 'rgba(255, 150, 150, 0.5)';
        ctx.beginPath();
        ctx.arc(cx - 7, cy - 4, 3, 0, Math.PI * 2);
        ctx.arc(cx + 7, cy - 4, 3, 0, Math.PI * 2);
        ctx.fill();
      } else {
        ctx.strokeStyle = '#5d4037';
        ctx.lineWidth = 1.5;
        ctx.beginPath();
        ctx.moveTo(cx - 3, cy - 2);
        ctx.lineTo(cx + 3, cy - 2);
        ctx.stroke();
      }
      
      ctx.restore();
    }
    
    // Floating hearts when happy/petting (calm or win phase)
    if (gamePhase === 'calm' || gamePhase === 'win') {
      if (Math.random() < 0.05) {
        owner.hearts.push({
          x: cx + (Math.random() - 0.5) * 20,
          y: cy - 15,
          vx: (Math.random() - 0.5) * 0.5,
          vy: -1 - Math.random(),
          life: 60,
          size: 10 + Math.random() * 6,
        });
      }
      
      for (let i = owner.hearts.length - 1; i >= 0; i--) {
        const h = owner.hearts[i];
        h.x += h.vx;
        h.y += h.vy;
        h.vy *= 0.98;
        h.life--;
        
        if (h.life <= 0) {
          owner.hearts.splice(i, 1);
          continue;
        }
        
        ctx.globalAlpha = h.life / 60;
        ctx.font = `${h.size}px sans-serif`;
        const heartEmoji = Math.random() > 0.7 ? 'üíï' : '‚ù§Ô∏è';
        ctx.fillText(heartEmoji, h.x - h.size/2, h.y);
        ctx.globalAlpha = 1;
      }
    } else {
      owner.hearts = [];
    }
  }
  
  // Draw Doober
  const dooberScreenX = (doober.x - camera.x) * TILE;
  const dooberScreenY = (doober.y - camera.y) * TILE;
  
  // Update Doober animation - speed tied to movement
  const speed = Math.sqrt(doober.velX ** 2 + doober.velY ** 2);
  if (doober.moving && speed > 0.01) {
    // Faster movement = faster animation
    doober.animTimer += speed * 50;
    if (doober.animTimer >= 1) {
      doober.animTimer = 0;
      doober.animFrame = (doober.animFrame + 1) % 4;
    }
  } else {
    // Idle animation - slow bobbing
    doober.animTimer += 0.05;
    if (doober.animTimer >= 1) {
      doober.animTimer = 0;
      doober.animFrame = (doober.animFrame + 1) % 4;
    }
  }
  
  // Determine direction based on velocity
  if (Math.abs(doober.velX) > Math.abs(doober.velY)) {
    doober.direction = doober.velX > 0 ? 2 : 3; // right or left
  } else if (Math.abs(doober.velY) > 0.01) {
    doober.direction = doober.velY > 0 ? 0 : 1; // down or up
  }
  
  if (!doober.hidden || gamePhase !== 'hide') {
    // Try to draw sprite, fall back to canvas drawing
    const spriteRow = doober.moving ? (doober.direction === 1 ? 2 : (doober.direction >= 2 ? 3 : 1)) : 0;
    const flipX = doober.direction === 3; // Flip for left-facing
    const spriteScale = TILE * 1.2 / (sprites.doober.frameWidth || 64);
    const offsetX = dooberScreenX - TILE * 0.1;
    const offsetY = dooberScreenY - TILE * 0.3;
    
    if (!drawSprite('doober', doober.animFrame, spriteRow, offsetX, offsetY, spriteScale, flipX)) {
      // Fallback: canvas-drawn Doober
      const dx = dooberScreenX + TILE/2;
      const dy = dooberScreenY + TILE/2;
      
      ctx.save();
      if (doober.facing === -1) {
        ctx.translate(dx, dy);
        ctx.scale(-1, 1);
        ctx.translate(-dx, -dy);
      }
      
      // Shadow
      ctx.fillStyle = 'rgba(0,0,0,0.25)';
      ctx.beginPath();
      ctx.ellipse(dx, dy + TILE/3, TILE/2.5, TILE/6, 0, 0, Math.PI * 2);
      ctx.fill();
      
      // Body base - warm tan like real Doober
      ctx.fillStyle = '#c87533';
      ctx.beginPath();
      ctx.ellipse(dx, dy, TILE/2.2, TILE/3, 0, 0, Math.PI * 2);
      ctx.fill();
      
      // Black saddle marking on back
      ctx.fillStyle = '#1a1a1a';
      ctx.beginPath();
      ctx.ellipse(dx - TILE/8, dy - 2, TILE/4, TILE/5, 0.2, 0, Math.PI * 2);
      ctx.fill();
      
      // White chest - pure bright white
      ctx.fillStyle = '#ffffff';
      ctx.beginPath();
      ctx.ellipse(dx + TILE/6, dy + 4, TILE/4.5, TILE/3.5, 0, 0, Math.PI * 2);
      ctx.fill();
      
      // Head - warm tan
      ctx.fillStyle = '#c87533';
      ctx.beginPath();
      ctx.arc(dx + TILE/4, dy - 3, TILE/3.5, 0, Math.PI * 2);
      ctx.fill();
      
      // White muzzle blaze - pure white
      ctx.fillStyle = '#ffffff';
      ctx.beginPath();
      ctx.ellipse(dx + TILE/3 + 2, dy - 1, TILE/5.5, TILE/4.5, 0, 0, Math.PI * 2);
      ctx.fill();
      
      // Floppy ears - rich warm tan
      ctx.fillStyle = '#b5642a';
      ctx.beginPath();
      ctx.ellipse(dx + TILE/4 - 7, dy - TILE/4 + 4, 6, 12, -0.4, 0, Math.PI * 2);
      ctx.fill();
      ctx.beginPath();
      ctx.ellipse(dx + TILE/4 + 9, dy - TILE/4 + 3, 6, 11, 0.3, 0, Math.PI * 2);
      ctx.fill();
      
      // Tail with white tip
      ctx.strokeStyle = '#c87533';
      ctx.lineWidth = 4;
      ctx.lineCap = 'round';
      ctx.beginPath();
      const tailWag = Math.sin(doober.tailWag * 3) * 8;
      ctx.moveTo(dx - TILE/3, dy);
      ctx.quadraticCurveTo(dx - TILE/2 - 4, dy + tailWag, dx - TILE/2 - 6, dy - 6 + tailWag/2);
      ctx.stroke();
      // White tail tip
      ctx.strokeStyle = '#ffffff';
      ctx.lineWidth = 3;
      ctx.beginPath();
      ctx.moveTo(dx - TILE/2 - 4, dy - 4 + tailWag/2);
      ctx.lineTo(dx - TILE/2 - 6, dy - 6 + tailWag/2);
      ctx.stroke();
      
      // Eyes - jet black
      ctx.fillStyle = '#0a0a0a';
      ctx.beginPath();
      ctx.arc(dx + TILE/4 - 2, dy - 6, 2.5, 0, Math.PI * 2);
      ctx.arc(dx + TILE/4 + 6, dy - 6, 2.5, 0, Math.PI * 2);
      ctx.fill();
      
      // Eye highlights
      ctx.fillStyle = '#fff';
      ctx.beginPath();
      ctx.arc(dx + TILE/4 - 1, dy - 7, 1, 0, Math.PI * 2);
      ctx.arc(dx + TILE/4 + 7, dy - 7, 1, 0, Math.PI * 2);
      ctx.fill();
      
      // Nose - jet black
      ctx.fillStyle = '#0a0a0a';
      ctx.beginPath();
      ctx.ellipse(dx + TILE/3 + 5, dy - 1, 3.5, 2.5, 0, 0, Math.PI * 2);
      ctx.fill();
      
      ctx.restore();
    }
  } else {
    ctx.globalAlpha = 0.35;
    ctx.fillStyle = '#c87533';
    ctx.beginPath();
    ctx.arc(dooberScreenX + TILE/2, dooberScreenY + TILE/2, TILE/4, 0, Math.PI * 2);
    ctx.fill();
    ctx.globalAlpha = 1;
    ctx.font = '12px sans-serif';
    ctx.fillText('ü§´', dooberScreenX + TILE/2 - 6, dooberScreenY + TILE/2 + 4);
  }
  
  for (const ft of floatingTexts) {
    const fx = (ft.x / TILE - camera.x) * TILE;
    const fy = (ft.y / TILE - camera.y) * TILE + ft.life - 60;
    ctx.globalAlpha = ft.life / 60;
    ctx.fillStyle = ft.color;
    ctx.font = 'bold 14px sans-serif';
    ctx.fillText(ft.text, fx, fy);
    ctx.globalAlpha = 1;
  }
  
  // Draw particles
  for (const p of particles) {
    const screenX = p.x - camera.x * TILE;
    const screenY = p.y - camera.y * TILE;
    
    // Simple culling
    if (screenX < -10 || screenX > canvas.width + 10 || screenY < -10 || screenY > canvas.height + 10) continue;
    
    ctx.fillStyle = p.color;
    ctx.globalAlpha = Math.max(0, p.life / 50);
    ctx.fillRect(screenX, screenY, p.size, p.size);
    ctx.globalAlpha = 1;
  }
  
  drawMinimap();
}

function drawMinimap() {
  const scale = 2;
  minimapCtx.fillStyle = '#1a1a2e';
  minimapCtx.fillRect(0, 0, 120, 100);
  
  for (const [name, room] of Object.entries(rooms)) {
    minimapCtx.fillStyle = room.color;
    minimapCtx.globalAlpha = 0.7;
    minimapCtx.fillRect(room.x * scale, room.y * scale, room.w * scale, room.h * scale);
  }
  minimapCtx.globalAlpha = 1;
  
  minimapCtx.fillStyle = '#f39c12';
  minimapCtx.beginPath();
  minimapCtx.arc(doober.x * scale, doober.y * scale, 3, 0, Math.PI * 2);
  minimapCtx.fill();
  
  for (const owner of owners) {
    minimapCtx.fillStyle = owner.state === 'searching' ? '#e74c3c' : '#3498db';
    minimapCtx.beginPath();
    minimapCtx.arc(owner.x * scale, owner.y * scale, 2, 0, Math.PI * 2);
    minimapCtx.fill();
  }
  
  minimapCtx.strokeStyle = '#fff';
  minimapCtx.lineWidth = 1;
  minimapCtx.strokeRect(camera.x * scale, camera.y * scale, VIEWPORT_COLS * scale, VIEWPORT_ROWS * scale);
}

function showMessage(text) {
  document.getElementById('message-text').innerHTML = text;
  document.getElementById('message').style.display = 'block';
}

function startGame() {
  gamePhase = 'mischief';
  mischiefLevel = 0;
  angerLevel = 100;
  doober.x = 8; doober.y = 17;
  doober.velX = 0; doober.velY = 0;
  doober.hidden = false;
  keys.up = keys.down = keys.left = keys.right = false;
  mischiefSpots.forEach(s => s.used = false);
  
  owners[0].x = owners[0].homeX; owners[0].y = owners[0].homeY;
  owners[0].state = 'idle'; owners[0].searchPath = [];
  owners[1].x = owners[1].homeX; owners[1].y = owners[1].homeY;
  owners[1].state = 'idle'; owners[1].searchPath = [];
  
  document.getElementById('mischief-meter').style.display = 'block';
  document.getElementById('anger-meter').style.display = 'none';
  document.getElementById('message').style.display = 'none';
  floatingTexts = [];
  particles = [];
}

// ============================================
// MENU SYSTEM
// ============================================
let gameStarted = false;

function showTitleScreen() {
  document.getElementById('title-screen').classList.remove('hidden');
  document.getElementById('ui').style.display = 'none';
  document.getElementById('phase-indicator').style.display = 'none';
  document.getElementById('minimap').style.display = 'none';
  document.getElementById('instructions').style.display = 'none';
}

function hideTitleScreen() {
  document.getElementById('title-screen').classList.add('hidden');
  document.getElementById('ui').style.display = 'flex';
  document.getElementById('phase-indicator').style.display = 'block';
  document.getElementById('minimap').style.display = 'block';
  document.getElementById('instructions').style.display = 'block';
}

function startGameFromMenu() {
  audioManager.init();
  audioManager.playSfx('click');
  hideTitleScreen();
  gameStarted = true;
  startGame();
}

function showHowToPlay() {
  document.getElementById('how-to-play').classList.add('visible');
}

function hideHowToPlay() {
  document.getElementById('how-to-play').classList.remove('visible');
}

function showCredits() {
  document.getElementById('credits-modal').classList.add('visible');
}

function hideCredits() {
  document.getElementById('credits-modal').classList.remove('visible');
}

function returnToMenu() {
  document.getElementById('message').style.display = 'none';
  gameStarted = false;
  showTitleScreen();
}

// Phase transition animation
function animatePhaseChange(text) {
  const indicator = document.getElementById('phase-indicator');
  indicator.textContent = text;
  indicator.classList.remove('phase-flash');
  void indicator.offsetWidth; // Trigger reflow
  indicator.classList.add('phase-flash');
}

function gameLoop() {
  if (gameStarted) {
    update();
  }
  draw();
  requestAnimationFrame(gameLoop);
}

// Start with title screen visible
showTitleScreen();
gameLoop();
</script>
</body>
</html>
